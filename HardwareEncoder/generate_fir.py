#!/usr/bin/env python

# Generate n-tap FIR filter

from math import *
import sys

log2 = lambda x: int(ceil(log(x, 2)))

order = int(sys.argv[1])

def generate_fir_filter(order):

    latency = log2(order) + 1

    def generate_adders(inputs):
        return (inputs / 2, int(ceil(inputs/2.0) - inputs/2))
        
    print """
module FIR{order}(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = {latency};
parameter ORDER = {order};
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;
""".format(order=order, latency=latency)

    n_levels = log2(order)
    n_multipliers = order

    ############ Print the register declarations 

    registers = []
    inputs = ["level0_{i}".format(i=i) for i in range(0, n_multipliers)]

    registers.extend(inputs)
    for i in range(1, n_levels + 1):
        adders, regs = generate_adders(len(inputs))
        outputs = ["level{i}_{j}".format(i=i, j=j) for j in range(0, adders)]
        
        if (regs > 0):
            outputs.append("rlevel{i}_{jp1}".format(i=i,jp1=adders))
            
        registers.extend(outputs)
        inputs = outputs
        

    for r in registers:
        print "reg signed [15:0] %s;"%r

    ############## Print the reset #############

    print """
assign oValid = valid[LATENCY];
assign oResidual = %s;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;
"""%registers[-1]

    for r in registers:
        print " "*7,
        print "%s <= 0;"%r
        
    print """
    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    """
    ############## Print the Adder Tree ##########

    for i in range(0, n_multipliers):
        print " "*11,
        print "level0_{i} <= qlp_coeff[{i}]*data[{i}]".format(i=i) + ";"
        
        
    inputs = ["level0_{i}".format(i=i) for i in range(0, n_multipliers)]

    for i in range(1, n_levels + 1):
        adders, registers = generate_adders(len(inputs))
        outputs = ["level{i}_{j}".format(i=i, j=j) for j in range(0, adders)]
        if (registers > 0):
            outputs.append("rlevel{i}_{jp1}".format(i=i,jp1=adders))
        print
        
        for a in range(0, adders*2, 2):
            print " "*11,
            print outputs[a/2], "<=", inputs[a], "+", inputs[a+1] + ";"
        for r in range(0,registers):
            print " "*11,
            print outputs[-1], "<=", inputs[-1] + ";"
        
        inputs = outputs
    print

    print " "*7, "end"
    print " "*3, "end"

    print "end"

    print "endmodule"
    
print """
/* This code has been autogenerated by "generate_fir.py".
 * Modify at your own risk
 */
 """
    
for i in range(1, order + 1):
    generate_fir_filter(i)
