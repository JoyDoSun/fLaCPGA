
/* This code has been autogenerated by "generate_fir.py".
 * Modify at your own risk
 */
 

module FIR1(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 1;
parameter ORDER = 1;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;

assign oValid = valid[LATENCY];
assign oResidual = level0_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];

        end
    end
end
endmodule

module FIR2(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 2;
parameter ORDER = 2;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level1_0;

assign oValid = valid[LATENCY];
assign oResidual = level1_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level1_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];

            level1_0 <= level0_0 + level0_1;

        end
    end
end
endmodule

module FIR3(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 3;
parameter ORDER = 3;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level1_0;
reg signed [15:0] rlevel1_1;
reg signed [15:0] level2_0;

assign oValid = valid[LATENCY];
assign oResidual = level2_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level1_0 <= 0;
        rlevel1_1 <= 0;
        level2_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];

            level1_0 <= level0_0 + level0_1;
            rlevel1_1 <= level0_2;

            level2_0 <= level1_0 + rlevel1_1;

        end
    end
end
endmodule

module FIR4(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 3;
parameter ORDER = 4;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level2_0;

assign oValid = valid[LATENCY];
assign oResidual = level2_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level2_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;

            level2_0 <= level1_0 + level1_1;

        end
    end
end
endmodule

module FIR5(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 4;
parameter ORDER = 5;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] rlevel1_2;
reg signed [15:0] level2_0;
reg signed [15:0] rlevel2_1;
reg signed [15:0] level3_0;

assign oValid = valid[LATENCY];
assign oResidual = level3_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        rlevel1_2 <= 0;
        level2_0 <= 0;
        rlevel2_1 <= 0;
        level3_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            rlevel1_2 <= level0_4;

            level2_0 <= level1_0 + level1_1;
            rlevel2_1 <= rlevel1_2;

            level3_0 <= level2_0 + rlevel2_1;

        end
    end
end
endmodule

module FIR6(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 4;
parameter ORDER = 6;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] level2_0;
reg signed [15:0] rlevel2_1;
reg signed [15:0] level3_0;

assign oValid = valid[LATENCY];
assign oResidual = level3_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        level2_0 <= 0;
        rlevel2_1 <= 0;
        level3_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;

            level2_0 <= level1_0 + level1_1;
            rlevel2_1 <= level1_2;

            level3_0 <= level2_0 + rlevel2_1;

        end
    end
end
endmodule

module FIR7(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 4;
parameter ORDER = 7;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level0_6;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] rlevel1_3;
reg signed [15:0] level2_0;
reg signed [15:0] level2_1;
reg signed [15:0] level3_0;

assign oValid = valid[LATENCY];
assign oResidual = level3_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level0_6 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        rlevel1_3 <= 0;
        level2_0 <= 0;
        level2_1 <= 0;
        level3_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];
            level0_6 <= qlp_coeff[6]*data[6];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;
            rlevel1_3 <= level0_6;

            level2_0 <= level1_0 + level1_1;
            level2_1 <= level1_2 + rlevel1_3;

            level3_0 <= level2_0 + level2_1;

        end
    end
end
endmodule

module FIR8(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 4;
parameter ORDER = 8;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level0_6;
reg signed [15:0] level0_7;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] level1_3;
reg signed [15:0] level2_0;
reg signed [15:0] level2_1;
reg signed [15:0] level3_0;

assign oValid = valid[LATENCY];
assign oResidual = level3_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level0_6 <= 0;
        level0_7 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        level1_3 <= 0;
        level2_0 <= 0;
        level2_1 <= 0;
        level3_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];
            level0_6 <= qlp_coeff[6]*data[6];
            level0_7 <= qlp_coeff[7]*data[7];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;
            level1_3 <= level0_6 + level0_7;

            level2_0 <= level1_0 + level1_1;
            level2_1 <= level1_2 + level1_3;

            level3_0 <= level2_0 + level2_1;

        end
    end
end
endmodule

module FIR9(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 5;
parameter ORDER = 9;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level0_6;
reg signed [15:0] level0_7;
reg signed [15:0] level0_8;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] level1_3;
reg signed [15:0] rlevel1_4;
reg signed [15:0] level2_0;
reg signed [15:0] level2_1;
reg signed [15:0] rlevel2_2;
reg signed [15:0] level3_0;
reg signed [15:0] rlevel3_1;
reg signed [15:0] level4_0;

assign oValid = valid[LATENCY];
assign oResidual = level4_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level0_6 <= 0;
        level0_7 <= 0;
        level0_8 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        level1_3 <= 0;
        rlevel1_4 <= 0;
        level2_0 <= 0;
        level2_1 <= 0;
        rlevel2_2 <= 0;
        level3_0 <= 0;
        rlevel3_1 <= 0;
        level4_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];
            level0_6 <= qlp_coeff[6]*data[6];
            level0_7 <= qlp_coeff[7]*data[7];
            level0_8 <= qlp_coeff[8]*data[8];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;
            level1_3 <= level0_6 + level0_7;
            rlevel1_4 <= level0_8;

            level2_0 <= level1_0 + level1_1;
            level2_1 <= level1_2 + level1_3;
            rlevel2_2 <= rlevel1_4;

            level3_0 <= level2_0 + level2_1;
            rlevel3_1 <= rlevel2_2;

            level4_0 <= level3_0 + rlevel3_1;

        end
    end
end
endmodule

module FIR10(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 5;
parameter ORDER = 10;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level0_6;
reg signed [15:0] level0_7;
reg signed [15:0] level0_8;
reg signed [15:0] level0_9;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] level1_3;
reg signed [15:0] level1_4;
reg signed [15:0] level2_0;
reg signed [15:0] level2_1;
reg signed [15:0] rlevel2_2;
reg signed [15:0] level3_0;
reg signed [15:0] rlevel3_1;
reg signed [15:0] level4_0;

assign oValid = valid[LATENCY];
assign oResidual = level4_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level0_6 <= 0;
        level0_7 <= 0;
        level0_8 <= 0;
        level0_9 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        level1_3 <= 0;
        level1_4 <= 0;
        level2_0 <= 0;
        level2_1 <= 0;
        rlevel2_2 <= 0;
        level3_0 <= 0;
        rlevel3_1 <= 0;
        level4_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];
            level0_6 <= qlp_coeff[6]*data[6];
            level0_7 <= qlp_coeff[7]*data[7];
            level0_8 <= qlp_coeff[8]*data[8];
            level0_9 <= qlp_coeff[9]*data[9];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;
            level1_3 <= level0_6 + level0_7;
            level1_4 <= level0_8 + level0_9;

            level2_0 <= level1_0 + level1_1;
            level2_1 <= level1_2 + level1_3;
            rlevel2_2 <= level1_4;

            level3_0 <= level2_0 + level2_1;
            rlevel3_1 <= rlevel2_2;

            level4_0 <= level3_0 + rlevel3_1;

        end
    end
end
endmodule

module FIR11(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 5;
parameter ORDER = 11;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level0_6;
reg signed [15:0] level0_7;
reg signed [15:0] level0_8;
reg signed [15:0] level0_9;
reg signed [15:0] level0_10;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] level1_3;
reg signed [15:0] level1_4;
reg signed [15:0] rlevel1_5;
reg signed [15:0] level2_0;
reg signed [15:0] level2_1;
reg signed [15:0] level2_2;
reg signed [15:0] level3_0;
reg signed [15:0] rlevel3_1;
reg signed [15:0] level4_0;

assign oValid = valid[LATENCY];
assign oResidual = level4_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level0_6 <= 0;
        level0_7 <= 0;
        level0_8 <= 0;
        level0_9 <= 0;
        level0_10 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        level1_3 <= 0;
        level1_4 <= 0;
        rlevel1_5 <= 0;
        level2_0 <= 0;
        level2_1 <= 0;
        level2_2 <= 0;
        level3_0 <= 0;
        rlevel3_1 <= 0;
        level4_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];
            level0_6 <= qlp_coeff[6]*data[6];
            level0_7 <= qlp_coeff[7]*data[7];
            level0_8 <= qlp_coeff[8]*data[8];
            level0_9 <= qlp_coeff[9]*data[9];
            level0_10 <= qlp_coeff[10]*data[10];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;
            level1_3 <= level0_6 + level0_7;
            level1_4 <= level0_8 + level0_9;
            rlevel1_5 <= level0_10;

            level2_0 <= level1_0 + level1_1;
            level2_1 <= level1_2 + level1_3;
            level2_2 <= level1_4 + rlevel1_5;

            level3_0 <= level2_0 + level2_1;
            rlevel3_1 <= level2_2;

            level4_0 <= level3_0 + rlevel3_1;

        end
    end
end
endmodule

module FIR12(
    input wire iClock,
    input wire iEnable,
    input wire iReset,
    
    input wire iLoad, 
    input wire signed [11:0] iQLP,
    
    input wire iValid,
    input wire signed [15:0] iSample,
    
    output wire signed [15:0] oResidual,
    output wire oValid
    );

parameter LATENCY = 5;
parameter ORDER = 12;
parameter PRECISION = 12;
parameter SHIFT = 10;

integer i;
reg signed [11:0] qlp_coeff [0:ORDER];
reg signed [15:0] data[0:ORDER];
reg [3:0] coeff_count;
reg [LATENCY:0] valid;

reg signed [15:0] level0_0;
reg signed [15:0] level0_1;
reg signed [15:0] level0_2;
reg signed [15:0] level0_3;
reg signed [15:0] level0_4;
reg signed [15:0] level0_5;
reg signed [15:0] level0_6;
reg signed [15:0] level0_7;
reg signed [15:0] level0_8;
reg signed [15:0] level0_9;
reg signed [15:0] level0_10;
reg signed [15:0] level0_11;
reg signed [15:0] level1_0;
reg signed [15:0] level1_1;
reg signed [15:0] level1_2;
reg signed [15:0] level1_3;
reg signed [15:0] level1_4;
reg signed [15:0] level1_5;
reg signed [15:0] level2_0;
reg signed [15:0] level2_1;
reg signed [15:0] level2_2;
reg signed [15:0] level3_0;
reg signed [15:0] rlevel3_1;
reg signed [15:0] level4_0;

assign oValid = valid[LATENCY];
assign oResidual = level4_0;

always @(posedge iClock) begin
    if (iReset) begin
        for (i = 0; i < ORDER; i = i + 1) begin
            qlp_coeff[i] <= 0;
            data[i] <= 0;
        end
        
        valid <= 0;
        coeff_count <= 0;

        level0_0 <= 0;
        level0_1 <= 0;
        level0_2 <= 0;
        level0_3 <= 0;
        level0_4 <= 0;
        level0_5 <= 0;
        level0_6 <= 0;
        level0_7 <= 0;
        level0_8 <= 0;
        level0_9 <= 0;
        level0_10 <= 0;
        level0_11 <= 0;
        level1_0 <= 0;
        level1_1 <= 0;
        level1_2 <= 0;
        level1_3 <= 0;
        level1_4 <= 0;
        level1_5 <= 0;
        level2_0 <= 0;
        level2_1 <= 0;
        level2_2 <= 0;
        level3_0 <= 0;
        rlevel3_1 <= 0;
        level4_0 <= 0;

    end else if (iEnable) begin
        if (iLoad && coeff_count < ORDER) begin
            for (i = ORDER; i > 0; i = i - 1) begin
                qlp_coeff[i] <= qlp_coeff[i - 1];
            end 
            qlp_coeff[0] <= iQLP;
            coeff_count <= coeff_count + 1'b1;
        end else if (iValid) begin
            valid <= (valid << 1) | iValid;
            
            for (i = ORDER; i > 0; i = i - 1) begin
                data[i] <= data[i - 1];
            end 
            data[0] <= iSample;
    
            level0_0 <= qlp_coeff[0]*data[0];
            level0_1 <= qlp_coeff[1]*data[1];
            level0_2 <= qlp_coeff[2]*data[2];
            level0_3 <= qlp_coeff[3]*data[3];
            level0_4 <= qlp_coeff[4]*data[4];
            level0_5 <= qlp_coeff[5]*data[5];
            level0_6 <= qlp_coeff[6]*data[6];
            level0_7 <= qlp_coeff[7]*data[7];
            level0_8 <= qlp_coeff[8]*data[8];
            level0_9 <= qlp_coeff[9]*data[9];
            level0_10 <= qlp_coeff[10]*data[10];
            level0_11 <= qlp_coeff[11]*data[11];

            level1_0 <= level0_0 + level0_1;
            level1_1 <= level0_2 + level0_3;
            level1_2 <= level0_4 + level0_5;
            level1_3 <= level0_6 + level0_7;
            level1_4 <= level0_8 + level0_9;
            level1_5 <= level0_10 + level0_11;

            level2_0 <= level1_0 + level1_1;
            level2_1 <= level1_2 + level1_3;
            level2_2 <= level1_4 + level1_5;

            level3_0 <= level2_0 + level2_1;
            rlevel3_1 <= level2_2;

            level4_0 <= level3_0 + rlevel3_1;

        end
    end
end
endmodule
